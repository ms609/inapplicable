---
title: "Getting started with the inapplicable package"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting Started}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


`inapplicable` is an R package that allows parsimony search on morphological datasets that contain
inapplicable data, following the algorithm proposed by Brazeau, Guillerme and Smith (2017).

In brief, this algorithm modifies the Fitch algorithm to count the total number of homoplasious 
events on a tree.

# Installation
Before installing inapplicable, you need to install a development version of the `phangorn` package:

```r
# Install the devtools package from CRAN, if necessary
if(!require(devtools)) install.packages("devtools")

# Install a working development version of phangorn...
devtools::install_github('KlausVigo/phangorn', ref='7192bfb4403c35c16a7b735160525d272736b061') # 30 Oct 2017
```

Then the inapplicable package can be installed as normal, and loaded into R:

```r
# Get the latest stable version from CRAN:
install.packages('inapplicable')
# Or get the latest development version from GitHub:
devtools::install_github('ms609/inapplicable')
```

Once installed, load the inapplicable package into R using
```{r}
library(inapplicable)
```

# Scoring a tree, and conducting a tree search

Here's an example of using the package to conduct tree search.
You can load your own dataset like so:

```r
my.data <- ape::read.nexus.data('path/to/file')
```

But for now, we'll use the Vinther _et al._ dataset that's bundled with the package.
This dataset is small enough that it runs reasonably quickly, but its phylogenetic
signal is obscure enough that it can require Ratchet searches to escape from local optima.

```{r}
data(inapplicable.datasets)
my.data <- inapplicable.datasets[['Vinther2008']]
my.phyDat <- phangorn::phyDat(my.data, type='USER', levels=c(0:9, '-'))
```

We can generate a random tree and calculate its parsimony score thus:
```{r}
set.seed(0) # Set random seed so that random functions will generate consistent output in this document
random.tree <- TreeSearch::RandomTree(my.phyDat)
par(mar=rep(0.25, 4), cex=0.75) # make plot easier to read
plot(random.tree)
InapplicableFitch(random.tree, my.phyDat)
```

It helps tree search if we start with a tree that's a little closer to optimal; perhaps a
neighbour-joining tree:
```{r}
nj.tree <- ape::nj(phangorn::dist.hamming(my.phyDat))
# We need to set an arbitrary ougroup so that all nodes bifurcate
nj.tree <- ape::root(nj.tree, outgroup=names(my.phyDat)[1], resolve.root=TRUE)
nj.tree$edge.length <- NULL
par(mar=rep(0.25, 4), cex=0.75) # make plot easier to read
plot(nj.tree)
InapplicableFitch(nj.tree, my.phyDat)
```

With the Vinther _et al._ 2008 dataset, brachiopods and nemerteans form an natural outgroup to 
the other taxa. 
If we wish, we can avoid making tree rearrangements that would mix ingroup and outgroup taxa.
This will accellerate tree search, but it's worth thinking carefully whether you can be perfectly
confident that the ingroup and outgroup are mutually monophyletic.
First we need to separate the ingroup from the outgroup:

```{r}
outgroup <- c('Nemertean', 'Lingula', 'Terebratulina')
rooted.tree <- TreeSearch::EnforceOutgroup(nj.tree, outgroup)
par(mar=rep(0.25, 4), cex=0.75) # make plot easier to read
plot(rooted.tree)
```


Now let's see whether a few Nearest-neighbour interchanges can find us a better tree score. 
This tends to be the quickest search to run, if not the most exhaustive.
Using `RootedNNI` instead of `NNI` retains the position of the root, which you'll usually want to do.

```{r}
better.tree <- BasicSearch(tree=nj.tree, dataset=my.phyDat, Rearrange=TreeSearch::RootedNNI, verbosity=3)
```

Using NNI helps to explore the region of treespace close to the local optimum, but SPR and TBR 
rearrangements are better at escaping local optima, and find better trees
further away in tree space.  Using more hits (maxHits) and more iterations (maxIter) also
means we'll move closer to an optimal tree
```{r}
better.tree <- BasicSearch(better.tree, my.phyDat, maxHits=40, maxIter=100000, Rearrange=TreeSearch::RootedSPR, verbosity=2)
better.tree <- BasicSearch(better.tree, my.phyDat, maxHits=40, maxIter=100000, Rearrange=TreeSearch::RootedTBR, verbosity=2)
```

That score's looking better, but we might still be caught in a local optimum. 
A more comprehensive search of tree space can be accomplished using the Parsimony Ratchet.
It might take a couple of minutes to run.

```{r}
best.tree <- RatchetSearch(better.tree, my.phyDat, verbosity=0)
attr(best.tree, 'score')
```
Let's view the tree:
```{r}
par(mar=rep(0.25, 4), cex=0.75) # make plot easier to read
plot(best.tree)
```

This is just one most parsimonious tree; perhaps we want to make a consensus.  
One way to do that is to collect a number of optimal trees from independent Ratchet iterations.
For each Ratchet iteration, we'll conduct a TBR search to scan tree space, 
then an NNI search to hone in on the local optimum.
```{r}
my.consensus <- RatchetConsensus(best.tree, my.phyDat, Rearrangements=list(TreeSearch::RootedTBR, TreeSearch::RootedNNI))

```



# Reference

BRAZEAU, M. D., GUILLERME, T. and SMITH, M. R. 2017. [Morphological phylogenetic analysis with inapplicable data](https://www.biorxiv.org/content/early/2017/10/26/209775). BioRÏ‡iv. doi:10.1101/209775
