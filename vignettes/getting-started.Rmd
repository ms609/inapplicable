---
title: "Getting started with the inapplicable package"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting Started}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


`inapplicable` is an R package that allows parsimony search on morphological datasets that contain
inapplicable data, following the algorithm proposed by Brazeau, Guillerme and Smith (2017).

In brief, this algorithm modifies the Fitch algorithm to count the total number of homoplasious 
events on a tree.

# Installation
Before installing inapplicable, you need to install a development version of the `phangorn` package:

```r
# Install the devtools package from CRAN, if necessary
if(!require(devtools)) install.packages("devtools")

# Install a working development version of phangorn...
devtools::install_github('KlausVigo/phangorn', ref='7192bfb4403c35c16a7b735160525d272736b061') # 30 Oct 2017
```

Then the inapplicable package can be installed as normal, and loaded into R:

```r
# Get the latest stable version from CRAN:
install.packages('inapplicable')
# Or get the latest development version from GitHub:
devtools::install_github('ms609/inapplicable')
```

Once installed, load the inapplicable package into R using
```{r}
library('inapplicable')
```

# Scoring a tree, and conducting a tree search

Here's an example of using the package to conduct tree search.
You can load your own dataset like so:

```r
my.data <- ape::read.nexus.data('path/to/file')
```

But for now, we'll use the Asher dataset that's bundled with the package, 
as it's nice and small so runs quickly.

```{r}
data(inapplicable.datasets)
my.data <- inapplicable.datasets[['Asher2005']]
my.phyDat <- phangorn::phyDat(my.data, type='USER', levels=c(0:9, '-'))
```

We can generate a random tree and calculate its parsimony score thus:
```{r}
random.tree <- TreeSearch::RandomTree(my.phyDat)
InapplicableFitch(random.tree, my.phyDat)
```

It helps tree search if we start with a tree that's a little closer to optimal; perhaps a
neighbour-joining tree:
```{r}
nj.tree <- ape::nj(phangorn::dist.hamming(my.phyDat))
InapplicableFitch(nj.tree, my.phyDat)
```

Now let's see if we can find a better score:
```{r}
better.tree <- TreeSearch(tree=nj.tree, dataset=my.phyDat, Rearrange=TreeSearch::RootedNNI)
InapplicableFitch(better.tree, my.phyDat)
```


outgroup <- c('Didelphis', 'Macropus', 'Vombatus')

# Running a second search from this tree will probably see further improvements:
best <- TreeSearch(best, Lobo.phy)

# Using NNI might help to explore the region of treespace close to the local optimum:
best <- TreeSearch(best, Lobo.phy, Rearrange=TreeSearch::RootedNNI)

# SPR and TBR arrangements help to escape local optima and find better peaks 
# further away in tree space.  Using more hits (maxHits) and more iterations (maxIter)
# means we'll move closer to an optimal tree
best <- TreeSearch(best, Lobo.phy, maxHits=40, maxIter=100000, Rearrange=TreeSearch::RootedSPR, verbosity=2)
best <- TreeSearch(best, Lobo.phy, maxHits=40, maxIter=100000, Rearrange=TreeSearch::RootedTBR, verbosity=2)

# A more comprehensive search of tree space can be accomplished using the Parsimony Ratchet
# It might take a couple of minutes to run.
best <- Ratchet(best, Lobo.phy, verbosity=1)

# Let's view the tree:
plot(best)
```

# Reference

Details of the algorithm have been posted as a pre-print at 

BRAZEAU, M. D., GUILLERME, T. and SMITH, M. R. 2017. [Morphological phylogenetic analysis with inapplicable data](https://www.biorxiv.org/content/early/2017/10/26/209775). BioRÏ‡iv. doi:10.1101/209775


